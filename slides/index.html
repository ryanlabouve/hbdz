<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>HUNTING BEFORE DAY 0: RL</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/invader.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>
                Hunting Before Day Zero
            </h1>
            <p>
                By Ryan LaBouve
            </p>
        </section>
        <section>
            <p>$ whoami</p>
            <section>
                <h2>
                    Ryan LaBouve
                </h2>
                <p>
                <ul>
                    <li> Founder of Startup.Security</li>
                    <li>Disaster Recovery <br><small>(storms not hard-drives)</small></li>
                </ul>
            </section>
            <section>
                <h2>
                    Startup.Security
                </h2>
                <ul>
                    <li>Security the tools, technologies, companies that are building the future (we want)</li>
                    <li>Helping series A,B,C startups kickstart security</li>
                    <li>Security Observabilty Research</li>
                </ul>
            </section>
            <section>
                <p>My Background<br><small>Any Why this topic is interesting to me</small></p>
                <ul>
                    <li>üëá Software engineer</li>
                    <li>üëá SRE (DevOps+SysAdmin)</li>
                    <li>üëâ Security Observability & Strategy</li>
                </ul>
            </section>
            <section>
                <h3>Modus Operindi Mei</h3>
                <p>üßë‚Äçüéì First princples up</p>
                <small>(Not big tools down)</small>
                <p>üèïÔ∏è Bazzar > üè∞ Cathedral</p>
                <small>(OSS > Closed source)</small>
                <p>üé® Shameless Iteration</p>
                <small>(We're going to be wrong a lot, but learn each time</small>
            </section>
        </section>
        <!-- ############################################# -->
        <!-- 00. SET THE STAGE -->
        <!-- ############################################# -->

        <section>
            <h2>Today's Agenda</h2>
        </section>
        <section>
            <small>Today's Agenda</small>
            <section>
                <small>My main argument</small>
                <blockquote>
                    Understanding fundamental signals from Linux gives us insight to compromise.
                </blockquote>
            </section>
            <section style="text-transform: uppercase;">
                <ol>
                    <li>
                        <b>STORY MODE</b><br> <small>running into compromise</small>
                    </li>
                    <li>
                        <b>Signals of compromise</b><br><small>philosophy and methodology</small>
                    </li>
                    <li>
                        <b>Signals in the wild</b><br><small>Tactics & perspective</small>
                    </li>
                </ol>
            </section>
            <section>
                <h3>What you'll get out of this?</h3>
            </section>
            <section>
                <small>What you'll get out of this</small>
                <h4>Beginner / Intermediate Practitioner</h4>
                <p>
                    Better understanding of the signals available from Linux and how they can lead to situational
                    system awareness (which can help you hunt vulns on your system).
                </p>
            </section>
            <section>
                <small>What you'll get out of this</small>
                <h4>Intermediate / Advanced Practitioner</h4>
                <p>
                    Review fundamental signals produced by linux systems and push to use them
                    to understand potential and novel vulnerabilities on your hosts.
                </p>
            </section>
        </section>

        <!-- ############################################# -->
        <!-- 01. STORY MODE: RUNNING INTO SIGNS OF COMPROMISE -->
        <!-- ############################################# -->

        <section>
            <h2>
                I: STORY MODE: RUNNING INTO SIGNS OF COMPROMISE
            </h2>
        </section>
        <section>
            <small>
                I: STORY MODE: RUNNING INTO SIGNS OF COMPROMISE
            </small>
            <section>
                <blockquote>
                    How to accidentally<br> discover a zero-day
                </blockquote>
            </section>
            <section>
                <h3>Zero-day</h3>
                <blockquote>
                    A vulnerability that has not been publicly disclosed.
                </blockquote>
                <ul>
                    <li>No patch</li>
                    <li>No way to track</li>
                </ul>
            </section>
            <section>
                <p>Client:</p>
                <img alt="Logo to fake co" src="./assets/hyperion-logo.png" style="width: 50%;"/>
            </section>
            <section>
                <h3>Client goal: stand up firewall on a microservice</h3>
                <p>Critical service</p>
                <p>Service cannot go down</p>
            </section>
            <section>
                <h3>Startups in hyper-growth</h3>
                <p>
                    Growth is prioritized over everything (e.g. security)
                </p>
                <p>
                    Microservices a popular choice for companies in hyper-growth mode
                </p>
            </section>
            <section>
                <h3>Microservices growth mode math!</h3>
                <small>
                    I can...
                </small>
                <p>
                    i. "divide big problems into smaller problems
                </p>
                <p>
                    ii. "Hire 1 teams to solve 1 problem"
                </p>
                <p>
                    iii. 1000 problems? 1000 teams! QED
                </p>
            </section>
            <section>
                <img src="./assets/sad-dinos.png" alt="dinosauers crying">
            </section>
            <section>
                <h3>Microservices primer</h3>
                <p>Do one small thing!</p>
                <p>North-South vs East West traffic</p>
                <p>
                    Common for large companies to have 100's of microservices
                </p>
            </section>
            <section>
                Back to our story
            </section>
            <section>
                <h3>Infra at hyperion</h3>
                <img src="./assets/basic-infra.png" style="width: 50%;" alt="Infra at hyperion"/>
                <p>
                    We've simplified the infra a bit.
                </p>
            </section>
            <section>
                <h3>Infra at hyperion</h3>
                <img src="./assets/ns-ew.png" style="width: 50%;" alt="Infra at hyperion"/>
                <p>
                    Traffic Flow
                </p>
            </section>
            <section>
                <h3>Traffic patterns for RBAC service</h3>
                <p>
                    EW traffic to other services,
                </p>
                <p>
                    <img src="./assets/rbac-traffic.png" style="width: 50%;" alt="Infra at hyperion"/>
                </p>
            </section>
            <section>
                <h3>RBAC service at hyperion</h3>
                <p>
                    <img src="./assets/rbac-service.png" style="width: 50%;" alt="Infra at hyperion"/>
                </p>
            </section>


            <section>
                <h3>Technical Review of RBAC service</h3>
                <p>
                    Node API: /api/v1/authorize?user_id=1&resource_id=2&action=3
                </p>
                <p>
                    Redis cache (Key Value store) (on box)
                </p>
                <p>
                    Direct connection to user database (off box)
                </p>
            </section>

            <section>
                <h3>What could happen if we compromised this </h3>
                <p>
                    poison Redis cache
                </p>
                <p>
                    Exfil the data
                </p>
                <p>
                    Move laterally
                </p>
            </section>
            <section>
                <h3>How are we going to bring a firewall up?</h3>
                <p>Identify everyday traffic</p>
                <p>Identify maintence traffic</p>
                <p>Identify deploy traffic</p>
                <small>(Exercise 1)</small>
            </section>
        </section>

        <section>
            <small>
                I. STORY MODE: (EXERCISE) SYN / SYN-ACK's
            </small>
            <section>
                <h3>Our First Signals: SYN / SYN-ACK's</h3>
                <p>Image of syn and syn-ack in TCP</p>
            </section>
            <section>
                <p>We'll focus on TCP over UDP, ICMP, Other traffic</p>
            </section>
            <section>
                <p>Successful 3-way handshake</p>
                <img src="./assets/3-way-handshake.png" />
            </section>
            <section>
                <h3>Wireshark</h3>
                <p>
                    <img src="./assets/wireshark.png" />
                </p>
            </section>
            <section>
                <h3>TCPDump</h3>
                <code>
                    sudo tcpdump 'tcp[tcpflags] & tcp-syn != 0'
                </code>
                <img src="./assets/tcpdump.png" />
            </section>
            <section>
                <h3>
                    LibPCAP
                </h3>
                <p>
                    Libpcap is a library for capturing and processing network packets in real-time
                </p>
                <img src="./assets/libpcap.png" />
            </section>
            <section>
                <h3>
                    eBPF
                </h3>
                <p>
                    eBPF is a virtual machine that runs in the kernel and allows you to write programs that
                    can be attached to various kernel hooks.
                </p>

                <img src="./assets/ebpf.png" />
            </section>
            <section>
                <h3>
                    LibPCAP vs eBPF
                </h3>
                <aside class="notes">
                    eBPF and libpcap are both libraries used for capturing and processing network packets

                    eBPF is a more advanced / flexible. Wider range of tasks. User code in kernel.

                    libpcap is a simpler library that provides a platform-independent API for capturing and processing
                    network packets.
                </aside>
            </section>
            <section>
                <h3>
                    Our solution: <br> agent to track SYN / SYN-ACK
                </h3>
                <p>
                    Spits out counts to prom
                </p>
                <p>
                    transforms output to firewall
                </p>
            </section>
            <section>
                <h3>
                    Demo of tool
                </h3>
                <p>TODO: create demo of tool</p>
            </section>
        </section>

        <section>
            <h2>
                I/iii. STORY MODE: A TWIST IN TRAFFIC
            </h2>
        </section>
        <section>
            <small>
                I/iii. STORY MODE: A TWIST IN TRAFFIC
            </small>
            <section>
                <h3>After monitoring SYN / SYN-ACK's for a week</h3>
                <p>Noticed something weird</p>
            </section>
            <section>
                <h3>Unexpected E-W traffic</h3>
                <p>No reason RBAC service should be talking to email service</p>
            </section>
            <section>
                <h3>SUS: Tracking traffic</h3>
                <p>No reason RBAC service should be communicating to email service</p>
            </section>
            <section>
                <h3>Novel vulnerabilty</h3>
                <p>Doing data exfil</p>
            </section>
        </section>

        <!-- ############################################# -->
        <!-- ############################################# -->
        <!-- 02. SIGNALS OF COMPROMISE: PHILOSOPHY AND METHODOLOGY -->
        <!-- ############################################# -->
        <section>
            <h2>
                II. SIGNALS OF COMPROMISE: PHILOSOPHY AND METHODOLOGY
            </h2>
        </section>
        <section>
            <small>
                II. SIGNALS OF COMPROMISE: PHILOSOPHY AND METHODOLOGY
            </small>
            <section>
                <blockquote>Small signal can reveal quite a bit about a system</blockquote>
            </section>
            <section>
                Zooming out, what we did is observe a potential signal of compromise
            </section>
            <section>
                <h3>Classical approach for signals of compromise</h3>
                <ul>
                    <li>
                        Behavioral analysis
                    </li>
                    <li>
                        Signature based detection (e.g. file names or metadata)
                    </li>
                    <li>
                        Data-based learning (ML/AI/If statements)
                    </li>
                    <li>
                        Threat Intelligence databases
                    </li>
                </ul>
            </section>
            <section>
                <small>
                    My take from SRE land
                </small>
                <h3>Monitoring vs Observability</h3>
                <p>Monitoring -> I can collect all the events in a system</p>
                <p>
                    Observability -> I can understand the system based on certain outputs
                </p>
            </section>
            <section>
                <small>tool for hunting</small>
                <h3>"Fundamental signal"</h3>
                <p>
                    A granular observable event on a system. E.g. system call.
                </p>
                <p>
                    Event
                </p>
            </section>
            <section>
                <small>Using fundamental signals</small>
                <table>
                    <tr>
                        <td>Pros</td>
                        <td>
                            collection size, composability, expressiveness<br>
                        </td>
                    </tr>
                    <tr>
                        <td>

                            Cons
                        </td>
                        <td>
                            requires legwork (e.g. forensics, guessing), system knowledge<br>
                        </td>
                    </tr>
                </table>
            </section>
        </section>
        <section>
            <p>II. SIGNALS OF COMPROMISE: PHILOSOPHY AND METHODOLOGY // (SoC::Big_Signals)</p>
            <section>
                <h3>SoC // Big Signals</h3>
                <p>
                    A more complex and specific signal that's composed of several factors
                </p>
                <p>
                    "Circumstance"
                </p>
            </section>
            <section>
                <table>
                    <tr>
                        <td>
                            pros
                        </td>
                        <td>
                            context comes along for the ride, forensics included
                        </td>
                    </tr>
                    <tr>
                        <td>
                            cons
                        </td>
                        <td>
                            resource intensive, storage intensive, fragile
                        </td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Example using a big signal</h3>
                <h3>Detecting Cobalt strike (C2)</h3>
            </section>

            <section>
                <small>Signature based detection,Cobalt strike beacon implant </small>
                <small>
                    "identifies an adversary using a Cobalt Strike beacon implant to pivot and issue commands over SMB through the use of configurable named pipes..."
                </small>
                <pre>
<code>
file_modifications_include ('pipe\msagent_', \
    'pipe\lsarpc_', 'pipe\samr_', ...)

</code>
                </pre>

                <small>
                    <a href="https://redcanary.com/threat-detection-report/threats/cobalt-strike/">
                        https://redcanary.com/threat-detection-report/threats/cobalt-strike/
                    </a>
                </small>
            </section>
            <section>
                <small>Another signature based detection of Cobalt Strike</small>
                <p>
                    Rundll32.exe to span SQL Server Client Configuration Utility
                </p>
                <small>
                    "identifies instances of rundll32.exe spawning the SQL Server Client Configuration Utility (cliconfg.exe). We often see this pattern of process execution when Cobalt Strike leverages DLL Search Order Hijacking as a method of UAC bypass."
                </small>
                <pre>
<code>
    parent_process == rundll32.exe
    &&
    process == cliconfg.exe

</code>
                    </pre>
                <small>
                    <a href="https://redcanary.com/threat-detection-report/threats/cobalt-strike/">
                        https://redcanary.com/threat-detection-report/threats/cobalt-strike/
                    </a>
                </small>
            </section>
            <section>
                <small>
                    Command-line patterns for cobalt strike beacons via GetSystem
                </small>
                <pre>
<code>
    process == cmd.exe
    &&
    command_line_includes ('/(?i)echo\s+[0-9a-f]{11}\s+\>\;?\s+\\\\\.\\pipe\\[0-9a-f]{6}/.match')

</code>
                    </pre>
                <small>
                    The above regular expression will match on the following example what of using GetSystem may look like via a Cobalt Strike beacon:
                </small>
                <pre>
<code>
C:\Windows\system32\cmd.exe /c echo 92d8cc45954 >; \\.\pipe\446b3c

</code>
                </pre>
                <small>
                    <a href="https://redcanary.com/threat-detection-report/threats/cobalt-strike/">
                        https://redcanary.com/threat-detection-report/threats/cobalt-strike/
                    </a>
                </small>
            </section>
            <section>
                This is a game of cat a mouse
            </section>
        </section>
        <section>
            <p>II. SIGNALS OF COMPROMISE: PHILOSOPHY AND METHODOLOGY // small-signals</p>
            <section>
                Instead of looking for very specific C2's, let's describe the behavior of any C2<br>
                and describe it using small signals
            </section>
            <section>
                <h4>
                    C2's, what do?
                </h4>
                <ul>
                    <li>
                        Data exfiltration
                    </li>
                    <li>
                        Encrypt data for ransom
                    </li>
                    <li>
                        Lateral movement
                    </li>
                    <li>
                        Priv Esc
                    </li>
                    <li>
                        Deploying unwanted software (e.g. malware, miners, etc)
                    </li>
                    <li>
                        Sabotage
                    </li>
                </ul>
            </section>
            <section>
                <h4>
                    C2's, what do?
                </h4>
                <p>
                    Zooming in to data exfiltration
                </p>
                <small>
                    (i.e. moving your files)
                </small>
            </section>
            <section>
                <p>And let's note, your files can be moved in very sneaky ways</p>
                <img src="assets/sneaky-exfil.png" />
            </section>
            <section>
                <p>What small signals do we have to help us detect C2 based activity?</p>
                <table>
                   <tr>
                       <td>
                           üóÇÔ∏èFile system
                       </td>
                       <td>
                           üï∏Ô∏èNetwork
                       </td>
                   </tr>
                </table>
            </section>
            <section>
                <h3>Syscalls are the key.</h3>
                <p>This is the API any interaction happens with network and files at</p>
            </section>
            <section>
                <p>To explore with small signals successfully we need:</p>
                <ul>
                    <li>
                    Snoop syscalls => eBPF
                </li>
                <li>
                    way to collect them => prometheus
                </li>
                <li>
                    way to vizualize them => grafana
                </li>
                <li>
                    way to query/compose them => prometheus
                </li>
                </ul>
            </section>
            <section>
                <h3>
                    eBPF (Snooping Syscalls)
                </h3>
                <p>
                    Run user code in the kernal
                </p>
                <p>
                    What many "big tools" (e.g. CrowdStrike Falcon) uses to monitor endpoints
                </p>
            </section>

            <section>
                TODO: explain how eBPF is used to accomplish goal (speaker notes)
                <aside class="notes">
                    eBPF can be used to observe syscalls

                    Here are the general steps to observe these system calls using eBPF:

                    Write eBPF programs: Write eBPF programs in C that define the probes you want to attach to specific system calls or kernel functions. These programs should collect the data you're interested in, such as the number of calls, duration, or arguments. You can use the BPF helper functions and data structures (like BPF maps) to store and manipulate the collected data.

                    Compile the eBPF programs: Compile your eBPF programs using the clang compiler with the appropriate flags and target architecture. This will generate eBPF bytecode that can be loaded into the kernel.

                    Load the eBPF programs: Write a user-space loader program in a language like C or Python (using libraries like libbpf, BCC, or BPFtrace) that loads the compiled eBPF bytecode into the kernel, attaches the probes to the desired system calls or functions, and manages the lifecycle of the eBPF programs.

                    Retrieve and process data: The loader program should also handle the retrieval of data from the eBPF programs. This typically involves interacting with BPF maps or perf buffers to collect the data generated by your eBPF programs. You can then process and analyze this data as needed, such as calculating statistics, generating visualizations, or logging events.

                    Cleanup: When you're done observing the system calls, the loader program should unload the eBPF programs and release any allocated resources.


                    BCC (BPF Compiler Collection): A toolkit for creating efficient kernel tracing and manipulation programs using eBPF. BCC provides a set of tools and libraries for working with eBPF, along with various pre-built tools for common use cases. Check the official repository here: https://github.com/iovisor/bcc
                    BPFtrace: A high-level tracing language for eBPF that simplifies the creation of eBPF programs for various tracing purposes. BPFtrace allows you to write scripts that define the probes and actions to take, making it easier to observe system calls and other events. Visit the official repository here: https://github.com/iovisor/bpftrace
                    libbpf: A library for working with eBPF programs and BPF maps, providing a low-level API for loading, attaching, and interacting with eBPF programs. Check the official repository here: https://github.com/libbpf/libbpf
                    By using eBPF and the available tools, you can observe the system calls involved in TCP traffic and gain a deeper understanding of the network operations happening on your system.
                </aside>
            </section>

            <section>
                <p>Prometheus (Collect Metrics)</p>
                <p>
                    Counting system calls
                </p>
                <img src="assets/prom-console.png" />
            </section>
            <section>
                <p>
                    Grafana (Vizualization)
                </p>
                <p>
                    Can be used to visualize eBPF data
                </p>
                <img src="assets/grafana.png" />
            </section>
            <section>
                <p>Prometheus Query Language</p>
                <img src="assets/prom-ql.png" />
            </section>
        </section>
        <section>
            <h2>
                II/ii. SIGNALS OF COMPROMISE: FILE ACCESS
            </h2>
        </section>
        <section>
            <small>
                II/ii. SIGNALS OF COMPROMISE: FILE ACCESS
            </small>
            <section>
                Let's see how we can detect ex-fill from small signals
            </section>
            <section>
                Exfill is someone moving your files
            </section>

            <section>
                <p>Primer on files: definition</p>
                <p>
                    Files are the building blocks of linux systems
                </p>
                <p>
                    "Linux treats everything as a file (including files, directories, devices, processes)"
                </p>
            </section>
            <section>
                <p>Primer on files: details</p>
                <p>
                   File permissions
                </p>
                <p>
                    File paths
                </p>
                <p>
                    File hierarchy
                </p>
            </section>
            <section>
                <p>
                    File I/O (what we care about)
                </p>
                <p>
                    So if someone wants to move your files, what are they going to have to do?
                </p>
            </section>
            <section>
                Interacting with files at a system level

                <table>
                    <tr>
                        <td>
                            open():
                        </td>
                        <td style="font-size: 12px">
                            This system call is used to open an existing file or create a new one. It returns a file descriptor, a non-negative integer that represents an open file within the process. The open() call takes arguments specifying the file path, access mode (read, write, or both), and permissions (if creating a new file). Common access modes include O_RDONLY (read-only), O_WRONLY (write-only), and O_RDWR (read and write).
                        </td>
                    </tr>

                    <tr>
                        <td>
                            close()
                        </td>
                        <td style="font-size: 12px">
                            This call closes an open file by releasing the associated file descriptor. It is essential to close files after usage to prevent resource leaks and ensure that data is flushed to the storage device.
                        </td>
                    </tr>

                    <tr>
                        <td>
                            read()
                        </td>
                        <td style="font-size: 12px">
                            This system call reads data from an open file into a buffer. It takes a file descriptor, a buffer pointer, and the number of bytes to read as arguments. The read() call returns the number of bytes actually read or a negative value if an error occurs. When the end of the file is reached, read() returns 0.
                        </td>
                    </tr>

                    <tr>
                        <td>
                            write()
                        </td>
                        <td style="font-size: 12px">
                            This call writes data from a buffer to an open file. It takes a file descriptor, a buffer pointer, and the number of bytes to write as arguments. The write() call returns the number of bytes actually written or a negative value if an error occurs.
                        </td>
                    </tr>

                    <tr>
                        <td>
                            lseek()
                        </td>
                        <td style="font-size: 12px">
                            This system call is used to change the file offset of an open file. It allows for random access to a file's contents by specifying the new offset position relative to a reference point (SEEK_SET for the start of the file, SEEK_CUR for the current position, or SEEK_END for the end of the file). lseek() returns the resulting offset location or a negative value if an error occurs.
                        </td>
                    </tr>

                    <tr>
                        <td>
                            stat(), <br>fstat(),<br> and lstat()
                        </td>
                        <td style="font-size: 12px">
                            These calls retrieve information about a file, such as its size, permissions, and timestamps. stat() and lstat() take a file path as an argument, while fstat() takes a file descriptor. lstat() differs from stat() in that it retrieves information about a symbolic link itself rather than the file it points to.
                        </td>
                    </tr>

                    <tr>
                        <td>
                            rename()
                        </td>
                        <td style="font-size: 12px">
                            This system call renames a file or moves it to a different directory. It takes the old file path and the new file path as arguments.
                        </td>
                    </tr>


                    <tr>
                        <td>
                            unlink()
                        </td>
                        <td>
                            This call removes a file from the file system. It takes the file path as an argument. The file's storage space is released when all processes that have the file open close it.
                        </td>
                    </tr>

                    <tr>
                        <td>
                            fsync() and<br> fdatasync()
                        </td>
                        <td>
                            These calls ensure that all buffered data associated with an open file is written to the storage device. fsync() synchronizes both file data and metadata, while fdatasync() synchronizes only file data.
                        </td>
                    </tr>
                </table>
                <aside class="speaker-notes">
                    System calls are a fundamental interface between a user-space application and the Linux kernel. They allow user programs to request services from the kernel, such as file I/O, process management, memory management, and more. When it comes to Linux files, several important system calls facilitate file manipulation and I/O operations:
                </aside>
            </section>
            <section>
                File access patterns, File motifications, File creation and deletion,
                Proccess level access, Sensitive data access, File locks?
            </section>

            <section>
                <p>Example: File Opens</p>
            </section>
            <section>
                <p>Collect: File Opens</p>
            </section>
            <section>
                <p>Vizualize: File Opens</p>
            </section>
            <section>
                <p>Compose: File Opens</p>
            </section>
        </section>
        <section>
            <h2>
                II/iii. SIGNALS OF COMPROMISE: NETWORK ACCESS
            </h2>
        </section>
        <section>
            <small>
                II/ii. SIGNALS OF COMPROMISE: NETWORK
            </small>

            <section>
                <p>
                    Primer on networking in Linux
                </p>
                <small>
                    (Long story very very very short)
                </small>
            </section>
            <section>

                <table>

                    <tr>
                        <td>
                            Application
                        </td>
                        <td style="font-size: 12px;">
                            UI for creating message, formatting, or encryption then the transport layer.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Transport
                        </td>
                        <td style="font-size: 12px;">
                            (If TCP) establishes a connection via "three-way handshake".
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Segmentation
                        </td>
                        <td style="font-size: 12px;">
                            Once the connection is established, TCP divides the message into smaller chunks called segments.
                            Each segment includes a header containing essential information such as the source and destination port numbers,
                            sequence numbers, and checksums to ensure reliable and ordered transmission.

                        </td>
                    </tr>
                    <tr>
                        <td>
                            IP Layer
                        </td>
                        <td style="font-size: 12px;">
                            The segments are then passed to the Internet Protocol (IP) layer. IP adds its own header to each segment,
                            creating IP packets. The header includes the source and destination IP addresses, the time-to-live (TTL) value,
                            and other information required for routing.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Data link
                        </td>
                        <td style="font-size: 12px;">
                            The IP packets are handed over to the data link layer, where they are encapsulated into frames.
                            These frames contain additional headers and trailers, such as the source and destination MAC addresses,
                            which are needed for communication within the local network.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Physical layer
                        </td>
                        <td style="font-size: 12px;">
                            Wires and NICs
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Routing
                        </td>
                        <td style="font-size: 12px;">
                            Your router, which acts as the default gateway, forwards the packets to the next hop in the
                            network based on the destination IP address. This process is repeated across multiple routers and
                            networks until the packets reach the destination computer's network.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Reception
                        </td>
                        <td style="font-size: 12px;">
                            Once the packets arrive at the destination network, they travel through the data link and
                            physical layers, reaching the destination computer's network interface.
                            (More happens on the host)
                        </td>
                    </tr>
                </table>
            </section>
            <section>
                This process uses many syscalls
                <table>
                    <tr>
                        <td>
                            socket()
                        </td>
                        <td style="font-size: 12px;">
                            Creates a new socket, returning a file descriptor that refers to it. Takes the address family (e.g., AF_INET for IPv4 or AF_INET6 for IPv6), socket type (e.g., SOCK_STREAM for TCP), and protocol as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            bind()
                        </td>
                        <td style="font-size: 12px;">
                            Assigns a local address (IP and port) to the socket. Often used by servers to listen for incoming connections on a specific port. Takes the socket file descriptor and the local address as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            connect()
                        </td>
                        <td style="font-size: 12px;">
                            Initiates a connection to a remote server for a client application. Takes the socket file descriptor and the destination address (IP and port) as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            listen()
                        </td>
                        <td style="font-size: 12px;">
                            Configures a socket to listen for incoming connection requests from clients. Typically used by servers after bind(). Takes the socket file descriptor and a backlog value (the maximum number of pending connections) as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            accept()
                        </td>
                        <td style="font-size: 12px;">
                            Accepts an incoming connection request from a client, creating a new socket specifically for that connection. Takes the listening socket file descriptor and returns a new file descriptor for the accepted connection.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            recv()
                        </td>
                        <td style="font-size: 12px;">
                            Receives data from the connected remote socket. Takes the socket file descriptor, a pointer to a buffer for the received data, the buffer size, and optional flags as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            read()
                        </td>
                        <td style="font-size: 12px;">
                             A general file I/O system call that can be used to receive data from a connected remote socket. Takes the socket file descriptor, a pointer to a buffer for the received data, and the buffer size as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            select() or poll()
                        </td>
                        <td style="font-size: 12px;">
                            Monitors multiple file descriptors, including sockets, for events such as data availability for reading, readiness for writing, or exceptional conditions. Useful for managing multiple connections in a single-threaded application.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            getsockopt() and setsockopt()
                        </td>
                        <td style="font-size: 12px;">
                            Retrieves or sets socket options, respectively. These system calls allow for adjusting socket settings, such as timeouts, buffer sizes, or enabling/disabling specific features.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            shutdown()
                        </td>
                        <td style="font-size: 12px;">
                            Shuts down part or all of a full-duplex connection on a socket. Takes the socket file descriptor and a flag indicating which part of the connection to shut down (e.g., SHUT_RD for reading, SHUT_WR for writing, or SHUT_RDWR for both) as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            close()
                        </td>
                        <td style="font-size: 12px;">
                            Closes the socket connection and releases the associated file descriptor. Should be called after the connection is no longer needed to free resources and ensure proper cleanup.
                        </td>
                    </tr>
                </table>

            </section>
            <section>
                Let's focus on the 3-way TCP handshake
                <img src="assets/3-way-handshake.png">
            </section>
            <section>
                The three-way handshake in TCP is the process of establishing a connection between two endpoints by exchanging SYN (synchronize) and ACK (acknowledge) packets. The system calls involved in this process are typically:

                <ul>
                    <li>
                        socket(): Creates a new socket for communication. This call returns a socket file descriptor that is used for subsequent operations.
                    </li>
                    <li>
                        bind(): (Optional) Binds the socket to a specific local address and port. This is not always necessary, as the operating system will assign an ephemeral port automatically if connect() or listen() is called without a prior bind().
                    </li>
                    <li>
                        connect() (for the client side): Initiates a connection to the remote endpoint by sending a SYN packet. The operating system chooses an ephemeral local port if bind() was not called earlier. The client then waits for the server to respond with a SYN-ACK packet.
                    </li>
                    <li>
                        listen() (for the server side): Indicates that the socket is willing to accept incoming connection requests. The server socket is set to listen for incoming SYN packets from clients.
                    </li>
                    <li>
                        accept() (for the server side): Blocks and waits for a connection request from a client. When the server receives a SYN packet, it responds with a SYN-ACK packet. The accept() call returns a new socket file descriptor for the established connection with the client.
                    </li>
                </ul>

                After the client receives the SYN-ACK packet from the server, it sends an ACK packet to complete the handshake. The connection is now established, and both endpoints can use the send() and recv() system calls to transmit data.

            </section>
            <section>
                We want to listen to SYN and SYN-ACK to know what server's we're connecting to and how often
                <p>
                    connect() (for the client side): Initiates the connection to the remote endpoint by sending a SYN packet and waits for a SYN-ACK packet in response.
                </p>
            </section>

            <section>
                <p>Collect: SYN SYN-ACK</p>
            </section>
            <section>
                <p>Vizualize: </p>
            </section>
            <section>
                <p>Compose: File Opens</p>
            </section>
        </section>
        <!-- ############################################# -->
        <!-- ############################################# -->
        <!-- 03. CONCLUSIONS IN THE WILD -->
        <!-- ############################################# -->
        <section>
            <h2>
                III. CONCLUSIONS IN THE WILD
            </h2>
        </section>
        <section>
            <small>
                III. CONCLUSIONS IN THE WILD
            </small>
            <section>
                <p>The bigger and more abstract our tools get, the more we lose touch with what are systems are doing</p>
            </section>
            <section>
                <p>We are not beholden to $$$ to get insights to our system</p>
            </section>
            <section>
                <p>Earlier I said relying on big signals is a cat and mouse game</p>
                <p>Trying to break new vulns using small signals is a ghost hunt</p>
            </section>
            <section>
                <p>Happy hunting</p>
            </section>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,
        slideNumber: true,
        showSlideNumber: 'all',
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>
</body>
</html>
