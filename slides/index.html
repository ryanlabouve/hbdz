<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>HUNTING BEFORE DAY 0: RL</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/invader.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>
                Hunting Before Day Zero
            </h1>
            <p>
                By Ryan LaBouve
            </p>
        </section>
        <section>
            <p>$ whoami</p>
            <section>
                <h2>
                    Ryan LaBouve
                </h2>
                <p>
                <ul>
                    <li> Founder of Startup.Security</li>
                    <li>Disaster Recovery <br><small>(storms not hard-drives)</small></li>
                </ul>
                </p>
            </section>
            <section>
                <h2>
                    Startup.Security
                </h2>
                <ul>
                    <li>Security the tools, technologies, companies that are building the future (we want)</li>
                    <li>Helping series A,B,C startups kickstart security</li>
                    <li>Security Research</li>
                </ul>
                </p>
            </section>
            <section>
                <p>My Background<br><small>Any Why this topic is interesting to me</small></p>
                <ul>
                    <li>ðŸ‘‡ Software engineer</li>
                    <li>ðŸ‘‡ DevOps+SysAdmin</li>
                    <li>ðŸ‘‰ Offensive Security</li>
                </ul>
            </section>
            <section>
                <h3>First principles up</h3>
                <p>Not big tools down</p>
                <p>OSS + DIY, startup life</p>
            </section>
        </section>
        <!-- ############################################# -->
        <!-- 00. SET THE STAGE -->
        <!-- ############################################# -->

        <section>
            <h2>Today's Agenda</h2>
        </section>
        <section>
            <small>Today's Agenda</small>
            <section>
                <small>My main argument</small>
                <blockquote>
                    Understanding fundamental signals from Linux gives us insight to compromise.
                </blockquote>
            </section>
            <section style="text-transform: uppercase;">
                <ol>
                    <li>
                        <b>STORY MODE</b><br> <small>Running into signs of compromise</small>
                    </li>
                    <li>
                        <b>Signals of compromise</b><br><small>philosophy and methodology</small>
                    </li>
                    <li>
                        <b>Signals in the wild</b><br><small>Conclusions and perspective</small>
                    </li>
                </ol>
            </section>
            <section>
                <h3>What you'll get out of this?</h3>
            </section>
            <section>
                <small>What you'll get out of this</small>
                <h4>Beginner / Intermediate Practitioner</h4>
                <p>
                    Better understanidng of the signals available from Linux and how they can lead to situational
                    system awareness.
                </p>
            </section>
            <section>
                <small>What you'll get out of this</small>
                <h4>Intermediate / Advanced Practitioner</h4>
                <p>
                    Understand that _basic_ signals produced by our systems give us the ability to hunt novel
                    vulnerabilities.
                </p>
            </section>
        </section>

        <!-- ############################################# -->
        <!-- 01. STORY MODE: RUNNING INTO SIGNS OF COMPROMISE -->
        <!-- ############################################# -->

        <section>
            <h2>
                I: STORY MODE: RUNNING INTO SIGNS OF COMPROMISE
            </h2>
        </section>
        <section>
            <small>
                I: STORY MODE: RUNNING INTO SIGNS OF COMPROMISE
            </small>
            <section>
                <blockquote>
                    How to accidentally<br> discover a zero-day
                </blockquote>
            </section>
            <section>
                <h3>Zero-day</h3>
                <blockquote>
                    A vulnerability that has not been publicly disclosed.
                </blockquote>
                <ul>
                    <li>No patch</li>
                    <li>No way to track</li>
                </ul>
            </section>
            <section>
                <p>Client:</p>
                <img alt="Logo to fake co" src="./assets/hyperion-logo.png" style="width: 50%;"/>
            </section>
            <section>
                <h3>Client goal: stand up firewall on a microservice</h3>
                <p>Critical service</p>
                <p>Service cannot go down</p>
            </section>
            <section>
                <h3>Startups in hyper-growth</h3>
                <p>
                    Growth is prioritied over everything (e.g. security)
                </p>
                <p>
                    Microservices a popular choice for companies in hyper-growth mode
                </p>
            </section>
            <section>
                <h3>Microservices growth mode math!</h3>
                <p>
                    I can...
                </p>
                <p>
                    i. "divide big problems into smaller problems
                </p>
                <p>
                    ii. "Hire 1 teams to solve 1 problem"
                </p>
                <p>
                    iii. 1000 problems? 1000 teams! QED
                </p>
            </section>
            <section>

                <img src="./assets/sad-dinos.png" alt="dinosauers crying">
            </section>
            <section>
                <h3>Microservices 101</h3>
                <p>Do one small thing!</p>
                <p></p>
                <p>North-South vs East West traffic</p>
                <p>
                    Common for large companies to have 100's of microservices
                </p>
            </section>
            <section>
                Back to our story
            </section>
            <section>
                <h3>Infra at hyperion</h3>
                <img src="./assets/basic-infra.png" style="width: 50%;" alt="Infra at hyperion"/>
                <p>
                    We've simplified the infra a bit.
                </p>
            </section>
            <section>
                <h3>Infra at hyperion</h3>
                <img src="./assets/ns-ew.png" style="width: 50%;" alt="Infra at hyperion"/>
                <p>
                    Traffic Flow
                </p>
            </section>
            <section>
                <h3>RBAC service at hyperion</h3>
                <p>
                    <img src="./assets/rbac-service.png" style="width: 50%;" alt="Infra at hyperion"/>
                </p>
            </section>
            <section>
                <h3>Traffic patterns for RBAC service</h3>
                <p>
                    EW traffic to other services,
                </p>
                <p>
                    <img src="./assets/rbac-traffic.png" style="width: 50%;" alt="Infra at hyperion"/>
                </p>
                <p>
                </p>
            </section>

            <section>
                <h3>Technical Review of RBAC service</h3>
                <p>
                    Node API: /api/v1/authorize?user_id=1&resource_id=2&action=3
                </p>
                <p>
                    Redis cache (Key Value store) (on box)
                </p>
                <p>
                    Direct connection to user database (off box)
                </p>
            </section>

            <section>
                <h3>What could happen if we compromised this </h3>
                <p>
                    poison Redis cache
                </p>
                <p>
                    Exfil the data
                </p>
                <p>
                    Move laterally
                </p>
            </section>
            <section>
                <h3>How are we going to bring a firewall up?</h3>
                <p>Identify everyday traffic</p>
                <p>Identify maintence traffic</p>
                <p>Identify deploy traffic</p>
                <p>(Exercise 1)</p>
            </section>
        </section>

        <section>
            <small>
                I. STORY MODE: (EXERCISE) SYN / SYN-ACK's
            </small>
            <section>
                <h3>Our First Signals: SYN / SYN-ACK's</h3>
                <p>Image of syn and syn-ack in TCP</p>
            </section>
            <section>
                <p>We'll focus on TCP over UDP, ICMP, Other traffic</p>
            </section>
            <section>
                <p>Successful 3-way handshake</p>
                <img src="./assets/3-way-handshake.png" />
            </section>
            <section>
                <h3>Wireshark</h3>
                <p>
                    <img src="./assets/wireshark.png" />
                </p>
            </section>
            <section>
                <h3>TCPDump</h3>
                <code>
                    sudo tcpdump 'tcp[tcpflags] & tcp-syn != 0'
                </code>
                <img src="./assets/tcpdump.png" />
            </section>
            <section>
                <h3>
                    LibPCAP
                </h3>
                <p>
                    Libpcap is a library for capturing and processing network packets in real-time
                </p>
                <img src="./assets/libpcap.png" />
            </section>
            <section>
                <h3>
                    eBPF
                </h3>
                <p>
                    eBPF is a virtual machine that runs in the kernel and allows you to write programs that
                    can be attached to various kernel hooks.
                </p>

                <img src="./assets/ebpf.png" />
            </section>
            <section>
                <h3>
                    LibPCAP vs eBPF
                </h3>
                <aside class="notes">
                    eBPF and libpcap are both libraries used for capturing and processing network packets

                    eBPF is a more advanced / flexible. Wider range of tasks. User code in kernel.

                    libpcap is a simpler library that provides a platform-independent API for capturing and processing
                    network packets.
                </aside>
            </section>
            <section>
                <h3>
                    Our solution: <br> agent to track SYN / SYN-ACK
                </h3>
                <p>
                    Spits out counts to prom
                </p>
                <p>
                    transforms output to firewall
                </p>
            </section>
            <section>
                <h3>
                    Demo of tool
                </h3>
                <p>TODO: create demo of tool</p>
            </section>
        </section>

        <section>
            <h2>
                I/iii. STORY MODE: A TWIST IN TRAFFIC
            </h2>
        </section>
        <section>
            <small>
                I/iii. STORY MODE: A TWIST IN TRAFFIC
            </small>
            <section>
                <h3>After monitoring SYN / SYN-ACK's for a week</h3>
                <p>Noticed something weird</p>
            </section>
            <section>
                <h3>Unexpected E-W traffic</h3>
                <p>No reason RBAC service should be talking to email service</p>
            </section>
            <section>
                <h3>SUS: Tracking traffic</h3>
                <p>No reason RBAC service should be communicating to email service</p>
            </section>
        </section>

        <section>
            <small>
                I/iv. STORY MODE: RED TEAM MODE ACTIVATE
            </small>
            <section>
                <p>Emoji before and after red-team mode</p>
            </section>
            <section>
                <p>Scan perimeter</p>
            </section>
            <section>
                <p>Detailed scan on open ports</p>
            </section>
            <section>
                <p>File upload form</p>
            </section>
            <section>
                <p>Upload reverse shell</p>
            </section>
            <section>
                Escalate via php GTFObin https://gtfobins.github.io/gtfobins/php/
            </section>
            <section>
                <p>Pivot into RBAC service</p>
            </section>
            <section>
                Scan network
            </section>
            <section>
                Sees host (RBAC service) running redis
            </section>
            <section>
                Accessible with no username and password (because, hey, we're in the internal network. why would we need a password)
            </section>
            <section>
                GTFObin redis, and we have root https://gtfobins.github.io/gtfobins/redis/
            </section>
            <section>
                <p>Shenanigans!</p>
                <ul>
                    <li>Spoof authentication</li>
                    <li>Exfil user data</li>
                    <li>Continue to move laterally</li>
                </ul>
            </section>
        </section>
        <!-- ############################################# -->
        <!-- ############################################# -->
        <!-- 02. SIGNALS OF COMPROMISE: PHILOSOPHY AND METHODOLOGY -->
        <!-- ############################################# -->
        <section>
            <h2>
                II. SIGNALS OF COMPROMISE: PHILOSOPHY AND METHODOLOGY
            </h2>
        </section>
        <section>
            <small>
                II. SIGNALS OF COMPROMISE: PHILOSOPHY AND METHODOLOGY
            </small>
            <section>
                <blockquote>Small signal can reveal quite a bit about a system</blockquote>
            </section>
            <section>
                Zooming out, what we did is provide a signal of compromise
            </section>
            <section>
                <h3>Classical approach for signals of compromise</h3>
                <ul>
                    <li>
                        Behavioral analysis
                    </li>
                    <li>
                        Signature based detection (e.g. file names or metadata)
                    </li>
                    <li>
                        Data-based learning (ML/AI/If statements)
                    </li>
                    <li>
                        Threat Intelligence databases
                    </li>
                </ul>
            </section>
            <section>
                <p>
                    My take from SRE land
                </p>
                <h3>Monitoring vs Observability</h3>
                <p>Monitoring -> I can collect all the events in a system</p>
                <p>
                    Observability -> I can understand the system based on certain outputs
                </p>
            </section>
            <section>
                Using basic signals to understand a system<br>
                pros: collection size, composability, expressiveness<br>
                cons: requires forenstics, system knowledge<br>
            </section>
            <section>
                Using big signals to understand a system<br>
                pros: context comes along for the ride, forensics included
                cons: resource intensive, storage intensive<br>
            </section>

            <section>
                <h3>Example using a big signal</h3>
                <h3>Cobalt strike</h3>
            </section>
            <section>
                <h3>Signature based detection</h3>
                <h3>Cobalt strike</h3>
                <p>
                    Cobalt strike beacon implant
                </p>
                <p>
                    Rundll32.exe to span SQL Server Client Configuration Utility
                </p>
                <p>
                    Command-line patterns for cobalt strike beacons via GetSystem
                </p>
                <small>
                    https://redcanary.com/threat-detection-report/threats/cobalt-strike/
                </small>
            </section>
            <section>
                <h3>Signature based detection</h3>
                <h3>Cobalt strike</h3>
                <p>
                    Cobalt strike beacon implant
                </p>
                <blockquote>
                    This detection analytic identifies an adversary using a Cobalt Strike beacon implant to pivot and issue commands over SMB through the use of configurable named pipes. Cobalt Strike beacons have configurable options to allow SMB communication over named pipes, utilizing a host of default names commonly used by adversaries. Analysis should focus on any file modifications to a suspicious named pipe within this process.
                </blockquote>
                <code>
                    file_modifications_include ('pipe\msagent_', 'pipe\interprocess_', 'pipe\lsarpc_', 'pipe\samr_', 'pipe\netlogon_', 'pipe\wkssvc_', 'pipe\srvsvc_', 'pipe\mojo_', 'pipe\postex', 'pipe\status_', 'pipe\msse-')
                </code>
                <small>
                    https://redcanary.com/threat-detection-report/threats/cobalt-strike/
                </small>
            </section>
            <section>
                <h3>Signature based detection</h3>
                <h3>Cobalt strike</h3>
                <blockquote>
                    This analytic identifies instances of rundll32.exe spawning the SQL Server Client Configuration Utility (cliconfg.exe). We often see this pattern of process execution when Cobalt Strike leverages DLL Search Order Hijacking as a method of UAC bypass.
                </blockquote>
                <p>
                    Rundll32.exe to span SQL Server Client Configuration Utility
                </p>
                <code>
                    parent_process == rundll32.exe
                    &&
                    process == cliconfg.exe
                </code>
                <small>
                    https://redcanary.com/threat-detection-report/threats/cobalt-strike/
                </small>
            </section>
            <section>
                <h3>Signature based detection</h3>
                <h3>Cobalt strike</h3>
                <p>
                    Command-line patterns for cobalt strike beacons via GetSystem
                </p>
                <blockquote>
                    This analytic identifies commonly observed command-line patterns when Cobalt Strike beacons escalate privileges via the GetSystem feature. Adversaries use GetSystem to impersonate a token for the SYSTEM account. This level of access allows an adversary to perform privileged actions beyond that of an administrator.
                </blockquote>
                <code>
                    process == cmd.exe
                    &&
                    command_line_includes ('/(?i)echo\s+[0-9a-f]{11}\s+\>\;?\s+\\\\\.\\pipe\\[0-9a-f]{6}/.match')
                </code>
                <p>
                    The above regular expression will match on the following example what of using GetSystem may look like via a Cobalt Strike beacon:
                </p>
                <code>C:\Windows\system32\cmd.exe /c echo 92d8cc45954 >; \\.\pipe\446b3c</code>
                <small>
                    https://redcanary.com/threat-detection-report/threats/cobalt-strike/
                </small>
            </section>
            <section>
                This is a game of cat a mouse
            </section>
            <section>
                <h3>Ex; detecting C2 with basic signals</h3>
                <p>
                    What do C2's do?
                </p>
                <p>
                    Data exfiltration
                </p>
                <p>
                    Encrypt data for ransom
                </p>
                <p>
                    Lateral movement
                </p>
                <p>
                    Priv Esc
                </p>
                <p>
                    Deploying unwanted software (e.g. malware, miners, etc)
                </p>
                <p>
                    Sabotage
                </p>
            </section>
            <section>
                <p>What other small signals do we have to help us detect C2 based activity?</p>
                <p>
                    File system
                </p>
                <p>
                    Network
                </p>
            </section>
            <section>
                <p>To work with small signals successfully we need</p>
                <p>
                    way to collect them => eBPF/prometheus
                </p>
                <p>
                    way to vizualize them => grafana
                </p>
                <p>
                    way to query/compose them => prometheus
                </p>
            </section>
            <section>
                <h3>
                    eBPF
                </h3>
                <p>
                    Run user code in the kernal
                </p>
                <p>
                    What many "big tools" (e.g. CrowdStrike Falcon) uses to monitor endpoints
                </p>
                <p>
                    This will be a recurring theme in tracking signals
                </p>
            </section>
            <section>
                <h3>
                    Grafana
                </h3>
                <p>
                    Chose whatever tool you want, this one is common in my world and will map to any time series backed metrics vizualizer
                </p>
                <p>
                    Vizualization tool
                </p>
                <p>
                    Can be used to visualize eBPF data
                </p>
                <p>
                    Implementation detail. Use wahtever you want.
                </p>
            </section>
            <section>
                <h3>Prometheus Query Language</h3>
                <p>
                    Chose whatever tool you want, this one is common in my world and will map to any time series based metrics collector
                </p>
                <p>
                    Compose and vizualize our fidings
                </p>
                <p>
                    Implementation detail. Use wahtever you want.
                </p>
            </section>
        </section>
        <section>
            <h2>
                II/ii. SIGNALS OF COMPROMISE: FILE ACCESS
            </h2>
        </section>
        <section>
            <small>
                II/ii. SIGNALS OF COMPROMISE: FILE ACCESS
            </small>
            <section>
                <p>Primer on files</p>
                <p>
                    Files are the building blocks of linux systems
                </p>
                <p>
                    "Linux treats everything as a file (including files, directories, devices, processes)"
                </p>
            </section>
            <section>
                <p>Primer on files</p>
                <p>
                    File types: _regular files_, directories, sym links, block devices (hds, usb drives, etc, sockets, character devices (keyboards, mice) more
                </p>
            </section>
            <section>
                <p>
                   File permissions:
                </p>
                <p>
                    File paths,
                </p>
                File hierarchy
            </section>
            <section>
                <p>
                    File I/O (what we care about_
                </p>
            </section>
            <section>
                How we interact with file
                <p>
                    System calls are a fundamental interface between a user-space application and the Linux kernel. They allow user programs to request services from the kernel, such as file I/O, process management, memory management, and more. When it comes to Linux files, several important system calls facilitate file manipulation and I/O operations:

                    open(): This system call is used to open an existing file or create a new one. It returns a file descriptor, a non-negative integer that represents an open file within the process. The open() call takes arguments specifying the file path, access mode (read, write, or both), and permissions (if creating a new file). Common access modes include O_RDONLY (read-only), O_WRONLY (write-only), and O_RDWR (read and write).

                    close(): This call closes an open file by releasing the associated file descriptor. It is essential to close files after usage to prevent resource leaks and ensure that data is flushed to the storage device.

                    read(): This system call reads data from an open file into a buffer. It takes a file descriptor, a buffer pointer, and the number of bytes to read as arguments. The read() call returns the number of bytes actually read or a negative value if an error occurs. When the end of the file is reached, read() returns 0.

                    write(): This call writes data from a buffer to an open file. It takes a file descriptor, a buffer pointer, and the number of bytes to write as arguments. The write() call returns the number of bytes actually written or a negative value if an error occurs.

                    lseek(): This system call is used to change the file offset of an open file. It allows for random access to a file's contents by specifying the new offset position relative to a reference point (SEEK_SET for the start of the file, SEEK_CUR for the current position, or SEEK_END for the end of the file). lseek() returns the resulting offset location or a negative value if an error occurs.

                    stat(), fstat(), and lstat(): These calls retrieve information about a file, such as its size, permissions, and timestamps. stat() and lstat() take a file path as an argument, while fstat() takes a file descriptor. lstat() differs from stat() in that it retrieves information about a symbolic link itself rather than the file it points to.

                    rename(): This system call renames a file or moves it to a different directory. It takes the old file path and the new file path as arguments.

                    unlink(): This call removes a file from the file system. It takes the file path as an argument. The file's storage space is released when all processes that have the file open close it.

                    fsync() and fdatasync(): These calls ensure that all buffered data associated with an open file is written to the storage device. fsync() synchronizes both file data and metadata, while fdatasync() synchronizes only file data.
                </p>
            </section>
            <section>
                File access patterns, File motifications, File creation and deletion,
                Proccess level access, Sensitive data access, File locks?
            </section>

            <section>
                <p>Example: File Opens</p>
            </section>
            <section>
                <p>Collect: File Opens</p>
            </section>
            <section>
                <p>Vizualize: File Opens</p>
            </section>
            <section>
                <p>Compose: File Opens</p>
            </section>
        </section>
        <section>
            <h2>
                II/iii. SIGNALS OF COMPROMISE: NETWORK ACCESS
            </h2>
        </section>
        <section>
            <small>
                II/ii. SIGNALS OF COMPROMISE: NETWORK
            </small>
            <section>
                <p>Primer on network access</p>
                <p>
                    Wire to desire
                </p>
            </section>
            <section>
                Primer on networking in Linux
                (Long story very very very short)
            </section>
            <section>
                BIG VIEW

                Application layer: UI for creating message, formatting, or encryption then the transport layer.

                Transport layer: (If TCP) establishes a connection with the destination computer by performing a
                "three-way handshake". The handshake involves exchanging SYN (synchronize) and ACK (acknowledge) packets
                between the two computers to establish and confirm the connection.

                Segmentation: Once the connection is established, TCP divides the message into smaller chunks called segments.
                Each segment includes a header containing essential information such as the source and destination port numbers,
                sequence numbers, and checksums to ensure reliable and ordered transmission.

                Network layer (IP): The segments are then passed to the Internet Protocol (IP) layer,
                which is responsible for routing the data across the network. IP adds its own header to each segment,
                creating IP packets. The header includes the source and destination IP addresses, the time-to-live (TTL) value,
                and other information required for routing.

                Data link layer: The IP packets are handed over to the data link layer, where they are encapsulated into frames.
                These frames contain additional headers and trailers, such as the source and destination MAC addresses,
                which are needed for communication within the local network.

                Physical layer: The frames are then converted into electrical, optical, or radio signals, depending on
                the network medium, and transmitted across the local network to your router or gateway.

                Routing: Your router, which acts as the default gateway, forwards the packets to the next hop in the
                network based on the destination IP address. This process is repeated across multiple routers and
                networks until the packets reach the destination computer's network.

                Reception: Once the packets arrive at the destination network, they travel through the data link and
                physical layers, reaching the destination computer's network interface.

                (More happens on the host)
            </section>

            <section>
                <aside class="notes">
                    socket(): Creates a new socket, returning a file descriptor that refers to it. Takes the address family (e.g., AF_INET for IPv4 or AF_INET6 for IPv6), socket type (e.g., SOCK_STREAM for TCP), and protocol as arguments.

                    bind(): Assigns a local address (IP and port) to the socket. Often used by servers to listen for incoming connections on a specific port. Takes the socket file descriptor and the local address as arguments.

                    connect(): Initiates a connection to a remote server for a client application. Takes the socket file descriptor and the destination address (IP and port) as arguments.

                    listen(): Configures a socket to listen for incoming connection requests from clients. Typically used by servers after bind(). Takes the socket file descriptor and a backlog value (the maximum number of pending connections) as arguments.

                    accept(): Accepts an incoming connection request from a client, creating a new socket specifically for that connection. Takes the listening socket file descriptor and returns a new file descriptor for the accepted connection.

                    send(): Sends data to the connected remote socket. Takes the socket file descriptor, a pointer to the message buffer, the message length, and optional flags as arguments.

                    recv(): Receives data from the connected remote socket. Takes the socket file descriptor, a pointer to a buffer for the received data, the buffer size, and optional flags as arguments.

                    write(): A general file I/O system call that can be used to send data to a connected remote socket. Takes the socket file descriptor, a pointer to the message buffer, and the message length as arguments.

                    read(): A general file I/O system call that can be used to receive data from a connected remote socket. Takes the socket file descriptor, a pointer to a buffer for the received data, and the buffer size as arguments.

                    select() or poll(): Monitors multiple file descriptors, including sockets, for events such as data availability for reading, readiness for writing, or exceptional conditions. Useful for managing multiple connections in a single-threaded application.

                    getsockopt() and setsockopt(): Retrieves or sets socket options, respectively. These system calls allow for adjusting socket settings, such as timeouts, buffer sizes, or enabling/disabling specific features.

                    shutdown(): Shuts down part or all of a full-duplex connection on a socket. Takes the socket file descriptor and a flag indicating which part of the connection to shut down (e.g., SHUT_RD for reading, SHUT_WR for writing, or SHUT_RDWR for both) as arguments.

                    close(): Closes the socket connection and releases the associated file descriptor. Should be called after the connection is no longer needed to free resources and ensure proper cleanup.
                </aside>
            </section>
            <section>
                <aside class="notes">
                    eBPF can be used to observe syscalls

                    Here are the general steps to observe these system calls using eBPF:

                    Write eBPF programs: Write eBPF programs in C that define the probes you want to attach to specific system calls or kernel functions. These programs should collect the data you're interested in, such as the number of calls, duration, or arguments. You can use the BPF helper functions and data structures (like BPF maps) to store and manipulate the collected data.

                    Compile the eBPF programs: Compile your eBPF programs using the clang compiler with the appropriate flags and target architecture. This will generate eBPF bytecode that can be loaded into the kernel.

                    Load the eBPF programs: Write a user-space loader program in a language like C or Python (using libraries like libbpf, BCC, or BPFtrace) that loads the compiled eBPF bytecode into the kernel, attaches the probes to the desired system calls or functions, and manages the lifecycle of the eBPF programs.

                    Retrieve and process data: The loader program should also handle the retrieval of data from the eBPF programs. This typically involves interacting with BPF maps or perf buffers to collect the data generated by your eBPF programs. You can then process and analyze this data as needed, such as calculating statistics, generating visualizations, or logging events.

                    Cleanup: When you're done observing the system calls, the loader program should unload the eBPF programs and release any allocated resources.


                    BCC (BPF Compiler Collection): A toolkit for creating efficient kernel tracing and manipulation programs using eBPF. BCC provides a set of tools and libraries for working with eBPF, along with various pre-built tools for common use cases. Check the official repository here: https://github.com/iovisor/bcc
                    BPFtrace: A high-level tracing language for eBPF that simplifies the creation of eBPF programs for various tracing purposes. BPFtrace allows you to write scripts that define the probes and actions to take, making it easier to observe system calls and other events. Visit the official repository here: https://github.com/iovisor/bpftrace
                    libbpf: A library for working with eBPF programs and BPF maps, providing a low-level API for loading, attaching, and interacting with eBPF programs. Check the official repository here: https://github.com/libbpf/libbpf
                    By using eBPF and the available tools, you can observe the system calls involved in TCP traffic and gain a deeper understanding of the network operations happening on your system.
                </aside>
            </section>
            <section>
                <p>Syn / Syn - Acks</p>
                <aside class="notes">
                    Host:
                    socket(): Creates a new socket and returns a file descriptor to refer to it. This call takes the address family (e.g., AF_INET for IPv4 or AF_INET6 for IPv6), the socket type (e.g., SOCK_STREAM for TCP), and the protocol as arguments.
                    connect(): Initiates a connection to the destination computer. This call takes the socket file descriptor and the destination address (IP and port) as arguments.

                    Transport layer (TCP): When the connection is established through the connect() call, the "three-way handshake" occurs at the TCP layer. The handshake is managed by the kernel and is not directly visible to the application. However, the application may use the getsockopt() system call to check the socket's status or adjust settings.


                    send(): Takes the socket file descriptor, a pointer to the message buffer, the message length, and optional flags as arguments. The kernel segments the data into TCP segments, adding necessary headers.
                    write(): A more general file I/O system call that can also be used with sockets. Takes the socket file descriptor, a pointer to the message buffer, and the message length as arguments. The kernel then handles the segmentation as with send().
                </aside>
            </section>

            <section>
                <p>Collect: SYN SYN-ACK</p>
            </section>
            <section>
                <p>Vizualize: </p>
            </section>
            <section>
                <p>Compose: File Opens</p>
            </section>
        </section>
        <!-- ############################################# -->
        <!-- ############################################# -->
        <!-- 03. CONCLUSIONS IN THE WILD -->
        <!-- ############################################# -->
        <section>
            <h2>
                III. CONCLUSIONS IN THE WILD
            </h2>
        </section>
        <section>
            <small>
                III. CONCLUSIONS IN THE WILD
            </small>
            <section>
                <p>Some tools do this</p>
            </section>
            <section>
                <p>Many people lack understanidng in how their systems work</p>
                <p>C's talk</p>
            </section>
            <section>
                <p>Perfection is many things done well</p>
            </section>
            <section>
                <p>Understanidng your system is not a luxuary, it's a necessity</p>
            </section>
            <section>
                <p>We are not beholden to $$$ to get insights to our system</p>
            </section>
            <section>
                <p>We can hunt before day zero</p>
            </section>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,
        slideNumber: true,
        showSlideNumber: 'all',
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>
</body>
</html>
