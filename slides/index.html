<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>HUNTING BEFORE DAY 0: RL</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/invader.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>
                Hunting Before Day Zero
            </h1>
            <p>
                By Ryan LaBouve
            </p>
        </section>
        <section>
            <p>$ whoami</p>
            <section>
                <h2>
                    Ryan LaBouve
                </h2>
                <p>
                <ul>
                    <li>‚ö°Ô∏èFounder of Startup.Security</li>
                    <li>üå™Ô∏èDisaster Recoverer<br><small>(storms not hard-drives)</small></li>
                </ul>
            </section>
            <section>
                <h2>
                    Startup.Security
                </h2>
                <blockquote>
                    Secure the tools, technologies, companies that are building the future (we want)
                </blockquote>
                <ul>
                    <li>Helping series A,B,C startups kickstart security</li>
                    <li>Security Observability & Research</li>
                </ul>
            </section>
            <section>
                <p>My Background<br><small>Any Why this topic is interesting to me</small></p>
                <ul>
                    <li>üëá Software engineer</li>
                    <li>üëá SRE (DevOps+SysAdmin)</li>
                    <li>üëâ Security Observability & Strategy</li>
                </ul>
            </section>
            <section>
                <h3>Modus Operindi Mei</h3>
                <p>üßë‚Äçüéì First princples up</p>
                <small>(Not big tools down)</small>
                <p>üèïÔ∏è Bazzar > üè∞ Cathedral</p>
                <small>(OSS > Closed source)</small>
                <p>üé® Shameless Iteration</p>
                <small>(We're going to be wrong a lot, but learn each time)</small>
            </section>

            <section>
                <p>
                    üõùSlides, üßêCode, üêïA range to play with eBPF (built with Ansible + Vagrant, running
                    on virtualbox with a metrics server running prometheus and grafana as used in all the examples)
                    <br>
                    <a href="github.com/ryanlabouve/hbdz">github.com/ryanlabouve/hbdz</a>
                </p>
            </section>
            <section>
                <p>(There will be spelling errors)</p>
            </section>
        </section>
        <!-- ############################################# -->
        <!-- 00. SET THE STAGE -->
        <!-- ############################################# -->

        <section>
            <h2>Today's Agenda</h2>
        </section>
        <section>
            <small>Today's Agenda</small>
            <section>
                <small>My main argument</small>
                <blockquote>
                    Understanding fundamental signals from Linux gives us insight to compromise.
                </blockquote>
            </section>
            <section style="text-transform: uppercase;">
                <ol>
                    <li>
                        <b>STORY MODE</b><br> <small>running into compromise</small>
                    </li>
                    <li>
                        <b>Signals of compromise</b><br><small>philosophy and methodology</small>
                    </li>
                    <li>
                        <b>Signals in the wild</b><br><small>Tactics & perspective</small>
                    </li>
                </ol>
            </section>
            <section>
                <h3>What you'll get out of this?</h3>
            </section>
            <section>
                <small>What you'll get out of this</small>
                <h4>Beginner / Intermediate Practitioner</h4>
                <p>
                    Better understanding of the signals available from Linux and how they can lead to situational
                    system awareness (which can help you hunt vulns on your system).
                </p>
            </section>
            <section>
                <small>What you'll get out of this</small>
                <h4>Intermediate / Advanced Practitioner</h4>
                <p>
                    Convince you that having the ability to ask your system specific questions,
                    without relying on big tools is a superpower (and cool tools to do so).
                </p>
            </section>
        </section>

        <!-- ############################################# -->
        <!-- 01. STORY MODE: RUNNING INTO SIGNS OF COMPROMISE -->
        <!-- ############################################# -->

        <section>
            <h2>
                I: STORY MODE: RUNNING INTO SIGNS OF COMPROMISE
            </h2>
        </section>
        <section>
            <small>
                I: STORY MODE: RUNNING INTO SIGNS OF COMPROMISE
            </small>
            <section>
                <blockquote>
                    How to accidentally<br> discover a zero-day
                </blockquote>
            </section>
            <section>
                <h3>Zero-day</h3>
                <blockquote>
                    A vulnerability that has not been publicly disclosed.
                </blockquote>
                <ul>
                    <li>No patch</li>
                    <li>No way to track</li>
                </ul>
            </section>
            <section>
                <p>Client:</p>
                <img alt="Logo to fake co" src="./assets/hyperion-logo.png" style="width: 50%;"/>
            </section>
            <section>
                <h3>Client goal: stand up firewall on a microservice</h3>
                <p>Critical service</p>
                <p>Service cannot go down</p>
            </section>
            <section>
                <h3>Startups in hyper-growth</h3>
                <p>
                    Growth is prioritized over everything (e.g. security)
                </p>
                <p>
                    Microservices a popular choice for companies in hyper-growth mode
                </p>
            </section>
            <section>
                <h3>Microservices growth mode math!</h3>
                <small>
                    Why? Some leadership napkin math:
                </small>
                <p>
                    i. "divide big problems into smaller problems
                </p>
                <p>
                    ii. "Hire 1 teams to solve 1 problem"
                </p>
                <p>
                    iii. 1000 problems? 1000 teams! QED
                </p>
            </section>
            <section>
                <img src="./assets/sad-dinos.png" alt="dinosauers crying">
            </section>
            <section>
                <h3>Microservices primer</h3>
                <p>Do one small thing!</p>
                <p>North-South vs East West traffic</p>
                <p>
                    Common for large companies to have 100's of microservices
                </p>
            </section>
            <section>
                Back to our story
            </section>
            <section>
                <h3>Infra at hyperion</h3>
                <img src="./assets/basic-infra.png" style="width: 50%;" alt="Infra at hyperion"/>
                <p>
                    We've simplified the infra a bit.
                </p>
            </section>
            <section>
                <h3>Infra at hyperion</h3>
                <img src="./assets/ns-ew.png" style="width: 50%;" alt="Infra at hyperion"/>
                <p>
                    Traffic Flow
                </p>
            </section>
            <section>
                <h4>Traffic patterns for RBAC service</h4>
                <p>
                    <img src="./assets/rbac-traffic.png" style="width: 50%;" alt="Infra at hyperion"/>
                </p>
            </section>
            <section>
                <h3>RBAC service at hyperion</h3>
                <p>
                    <img src="./assets/rbac-service.png" style="width: 50%;" alt="Infra at hyperion"/>
                </p>
            </section>


            <section>
                <h4>Technical Review of RBAC service</h4>
                <p>
                    rbac.hyperion.boop/api/v1/authorize?user_id=1&resource_id=2&action=3
                </p>
                <pre>
                    <code>
{
    user: "1",
    action: "3",
    approve: true|false,
    expires_at: "2023-05-03 11:1111"
}
                    </code>
                </pre>
                <small>
                    (we'd probably issue a token)
                </small>

            </section>
            <section>
                <h3>What could happen if we compromised this </h3>
                <p>
                    poison Redis cache
                </p>
                <p>
                    Exfil the data
                </p>
                <p>
                    Move laterally
                </p>
            </section>
            <section>
                <h3>How are we going to bring a firewall up?</h3>
                <p>Identify everyday traffic</p>
                <p>Identify maintence traffic</p>
                <p>Identify deploy traffic</p>
                <small>(Exercise 1)</small>
            </section>
        </section>

        <section>
            <small>
                I. STORY MODE: (EXERCISE) SYN / SYN-ACK's
            </small>
            <section>
                <h3>Our First Signals: SYN / SYN-ACK's</h3>
            </section>
            <section>
                <p>We'll focus on TCP over UDP, ICMP, Other traffic</p>
            </section>
            <section>
                <p><small>Successful 3-way handshake</small></p>
                <img style="max-height: 40vh" src="./assets/3-way-handshake.png" />
            </section>
            <section>
                <h4>Wireshark</h4>
                <p>
                    <img style="max-height: 40vh" src="./assets/wireshark.png" />
                </p>
            </section>
            <section>
                <h4>TCPDump</h4>
                <img style="max-height: 40vh" src="./assets/tcpdump.png" />
            </section>
            <section>
                <h4>
                    LibPCAP
                </h4>
                <p>
                    <small>Libpcap is a library for capturing and processing network packets in real-time</small>
                </p>
                <img style="max-height: 35vh" src="./assets/libpcap.png" />
            </section>
            <section>
                <h4>
                    eBPF
                </h3>
                <blockquote>
                    eBPF is a virtual machine that runs in the kernel and allows you to write programs that
                    can be attached to various kernel hooks.
                </blockquote>

                <img style="max-height: 20vh" src="./assets/ebpf.png" />
            </section>

            <section>
                <h3>
                    Our solution: <br> agent to track SYN / SYN-ACK
                </h3>
                <p>
                    Spits out counts to prom
                </p>
                <p>
                    transforms output to firewall
                </p>
            </section>

        </section>

        <section>
            <h2>
                I/iii. STORY MODE: A TWIST IN TRAFFIC
            </h2>
        </section>
        <section>
            <small>
                I/iii. STORY MODE: A TWIST IN TRAFFIC
            </small>
            <section>
                <h3>After monitoring SYN / SYN-ACK's for a week</h3>
                <p>Noticed something weird</p>
            </section>
            <section>
                <h3>Unexpected E-W traffic</h3>
                <p>No reason RBAC service should be talking to email service</p>
            </section>
            <section>
                <h3>SUS: Tracking traffic</h3>
                <p>No reason RBAC service should be communicating to email service</p>
            </section>
            <section>
                <h3>Novel vulnerabilty</h3>
                <p>Doing data exfil</p>
            </section>
        </section>

        <!-- ############################################# -->
        <!-- ############################################# -->
        <!-- 02. SIGNALS OF COMPROMISE: PHILOSOPHY AND METHODOLOGY -->
        <!-- ############################################# -->
        <section>
            <h2>
                II. SIGNALS OF COMPROMISE: PHILOSOPHY AND METHODOLOGY
            </h2>
        </section>
        <section>
            <small>
                II. SIGNALS OF COMPROMISE: PHILOSOPHY AND METHODOLOGY
            </small>
            <section>
                <blockquote>Small signal can reveal quite a bit about a system</blockquote>
            </section>
            <section>
                Zooming out, what we did is observe a potential signal of compromise
            </section>
            <section>
                <h3>Classical approach for signals of compromise</h3>
                <ul>
                    <li>
                        Behavioral analysis
                    </li>
                    <li>
                        Signature based detection (e.g. file names or metadata)
                    </li>
                    <li>
                        Data-based learning (ML/AI/If statements)
                    </li>
                    <li>
                        Threat Intelligence databases
                    </li>
                </ul>
            </section>
            <section>
                <small>
                    My take from SRE land
                </small>
                <h3>Monitoring vs Observability</h3>
                <p>Monitoring -> I can collect all the exhaust from a system</p>
                <p>
                    Observability -> I can understand the system based on certain event
                </p>
            </section>
            <section>
                Big signals vs Small signals?</br>
                Complex vs Fundamental?<br>
            </section>

        </section>
        <section>
            <p>II. SIGNALS OF COMPROMISE: Big_Signals</p>
            <section>
                <h3>SoC // Big Signals</h3>
                <p>
                    A more complex and specific signal that's composed of several factors
                </p>
                <p>
                    "Circumstance"
                </p>
            </section>

            <section>
                <h3>Example using a big signal</h3>
                <h3>Detecting Cobalt strike (C2)</h3>
            </section>

            <section>
                <small>Signature based detection,Cobalt strike beacon implant </small>
                <small>
                    "identifies an adversary using a Cobalt Strike beacon implant to pivot and issue commands over SMB through the use of configurable named pipes..."
                </small>
                <pre>
<code>
file_modifications_include ('pipe\msagent_', \
    'pipe\lsarpc_', 'pipe\samr_', ...)

</code>
                </pre>

                <small>
                    <a href="https://redcanary.com/threat-detection-report/threats/cobalt-strike/">
                        https://redcanary.com/threat-detection-report/threats/cobalt-strike/
                    </a>
                </small>
            </section>
            <section>
                <small>Another signature based detection of Cobalt Strike</small>
                <p>
                    Rundll32.exe to span SQL Server Client Configuration Utility
                </p>
                <small>
                    "identifies instances of rundll32.exe spawning the SQL Server Client Configuration Utility (cliconfg.exe). We often see this pattern of process execution when Cobalt Strike leverages DLL Search Order Hijacking as a method of UAC bypass."
                </small>
                <pre>
<code>
    parent_process == rundll32.exe
    &&
    process == cliconfg.exe

</code>
                    </pre>
                <small>
                    <a href="https://redcanary.com/threat-detection-report/threats/cobalt-strike/">
                        https://redcanary.com/threat-detection-report/threats/cobalt-strike/
                    </a>
                </small>
            </section>
            <section>
                <small>
                    Command-line patterns for cobalt strike beacons via GetSystem
                </small>
                <pre>
<code>
    process == cmd.exe
    &&
    command_line_includes ('/(?i)echo\s+[0-9a-f]{11}\s+\>\;?\s+\\\\\.\\pipe\\[0-9a-f]{6}/.match')

</code>
                    </pre>
                <small>
                    The above regular expression will match on the following example what of using GetSystem may look like via a Cobalt Strike beacon:
                </small>
                <pre>
<code>
C:\Windows\system32\cmd.exe /c echo 92d8cc45954 >; \\.\pipe\446b3c

</code>
                </pre>
                <small>
                    <a href="https://redcanary.com/threat-detection-report/threats/cobalt-strike/">
                        https://redcanary.com/threat-detection-report/threats/cobalt-strike/
                    </a>
                </small>
            </section>
            <section>
                This is a game of cat a mouse
            </section>
        </section>
        <section>
            <p>II. SIGNALS OF COMPROMISE: small-signals</p>
            <section>
                Instead of looking for very specific C2's, let's describe the behavior of any C2<br>
                and describe it using small signals
            </section>
            <section>
                <small>tool for hunting</small>
                <h3>"Fundamental signal"</h3>
                <p>
                    A granular observable event on a system. E.g. system call.
                </p>
                <p>
                    Event
                </p>
            </section>
            <section>
                <h4>
                    C2's, what do?
                </h4>
                <ul>
                    <li>
                        Data exfiltration
                    </li>
                    <li>
                        Encrypt data for ransom
                    </li>
                    <li>
                        Lateral movement
                    </li>
                    <li>
                        Priv Esc
                    </li>
                    <li>
                        Deploying unwanted software (e.g. malware, miners, etc)
                    </li>
                    <li>
                        Sabotage
                    </li>
                </ul>
            </section>
            <section>
                <h4>
                    C2's, what do?
                </h4>
                <p>
                    Zooming in to data exfiltration
                </p>
                <small>
                    (i.e. moving your files)
                </small>
            </section>
            <section>
                <p>And let's note, your files can be moved in very sneaky ways</p>
                <img src="assets/sneaky-exfil.png" />
                <p><small>(but if your files are to be moved, they have to be accessed)</small></p>
            </section>
            <section>
                <p>What small signals do we have to help us detect C2 based activity?</p>
                <table>
                   <tr>
                       <td>
                           üóÇÔ∏èFile system
                       </td>
                       <td>
                           üï∏Ô∏èNetwork
                       </td>
                   </tr>
                </table>
            </section>
            <section>
                <h3>Syscalls are the key.</h3>
                <p>This is the API any interaction happens with network and files at</p>
            </section>
            <section>
                <p>To explore with small signals successfully we need:</p>
                <ul>
                    <li>
                    Snoop syscalls => eBPF
                </li>
                <li>
                    way to collect them => prometheus
                </li>
                <li>
                    way to vizualize them => grafana
                </li>
                <li>
                    way to query/compose them => prometheus
                </li>
                </ul>
            </section>
            <section>
                <h3>
                    eBPF (for Snooping Syscalls)
                </h3>
                <p>
                    Run user code in the kernal
                </p>
                <p>
                    Many popular tools use eBPF to observe systems (e.g. Crowdstrike Falcon)
                </p>
            </section>

            <section>
                <p>
                    How we use eBPF?
                </p>
                <table>
                    <tr>
                        <td style="font-size: 30px;">
                            1. Write eBPF program
                        </td>
                        <td style="font-size: 14px;">
                            Restricted C, defines probes (i.e. which calls you want to watch), these programs can collect / expose data you're interested in (via helpers like BPF maps
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 30px;">
                            2. Compile the program
                        </td>
                        <td style="font-size: 14px;">
                            using the clang compiler with the appropriate flags and target architecture, generates eBPF byte code, performs some saftey checks
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 30px;">
                            3. Load programs
                        </td>
                        <td style="font-size: 14px;">
                            Using language like C, Python, Go, etc... attach code to kernel. Manage lifecycle of program
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 30px;">
                            4. Process data
                        </td>
                        <td style="font-size: 14px;">
                             This typically involves interacting with BPF maps or perf buffers to collect the data generated by your eBPF programs.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 30px;">
                            5. Cleanup
                        </td>
                        <td style="font-size: 14px;">
                            When you're done observing the system calls, the loader program should unload the eBPF programs and release any allocated resources.
                        </td>
                    </tr>
                </table>
            </section>

            <section>
                <small>How we collect data on system calls? Prometheus</small>
                <img style="max-height: 40vh" src="assets/prom-console-go-pidtastrophy.png" />
            </section>
            <section>
                <small>
                    Grafana:  Can be used to visualize eBPF data
                </small>
                <img  style="max-height: 40vh" src="assets/grafana-go-pidtastrophy.png" />
            </section>
            <section>
                <small>Prometheus Query Language</small>
                <img  style="max-height: 40vh" src="assets/prom-console-query-go-pidtastrophy.png" />
            </section>
            <section>
                <p>Prometheus Query Language</p>
                <pre>
                <code>
rate(new_pid_count{instance="100.93.243.38:2112"}[1m])
                </code>
                    </pre>
            </section>
    </section>
        <section>
            <h2>
                II/ii. SIGNALS OF COMPROMISE: FILE ACCESS
            </h2>
        </section>
        <section>
            <small>
                II/ii. SIGNALS OF COMPROMISE: FILE ACCESS
            </small>
            <section>
                Let's see how we can detect ex-fill from small signals
            </section>
            <section>
                Exfill is someone moving your files
            </section>

            <section>
                <h4>Everything's a file on linux tho</h4>
                <p>
                    Files are the building blocks of linux systems
                </p>
                <p>
                    (including files, directories, devices, processes)
                </p>
            </section>

            <section>
                <p>
                    So if someone wants to move your files, what are they going to have to do?
                    How do we know if someone's reading our files?
                </p>
            </section>
            <section>
                Interacting with files at a system level

                <table>
                    <tr>
                        <td style="font-size: 25px">
                            open():
                        </td>
                        <td style="font-size: 12px">
                            This system call is used to open an existing file or create a new one. It returns a file descriptor, a non-negative integer that represents an open file within the process. The open() call takes arguments specifying the file path, access mode (read, write, or both), and permissions (if creating a new file). Common access modes include O_RDONLY (read-only), O_WRONLY (write-only), and O_RDWR (read and write).
                        </td>
                    </tr>

                    <tr>
                        <td style="font-size: 25px">
                            close()
                        </td>
                        <td style="font-size: 12px">
                            This call closes an open file by releasing the associated file descriptor. It is essential to close files after usage to prevent resource leaks and ensure that data is flushed to the storage device.
                        </td>
                    </tr>

                    <tr>
                        <td style="font-size: 25px">
                            read()
                        </td>
                        <td style="font-size: 12px">
                            This system call reads data from an open file into a buffer. It takes a file descriptor, a buffer pointer, and the number of bytes to read as arguments. The read() call returns the number of bytes actually read or a negative value if an error occurs. When the end of the file is reached, read() returns 0.
                        </td>
                    </tr>

                    <tr>
                        <td style="font-size: 25px">
                            write()
                        </td>
                        <td style="font-size: 12px">
                            This call writes data from a buffer to an open file. It takes a file descriptor, a buffer pointer, and the number of bytes to write as arguments. The write() call returns the number of bytes actually written or a negative value if an error occurs.
                        </td>
                    </tr>

                    <tr>
                        <td style="font-size: 25px">
                            lseek()
                        </td>
                        <td style="font-size: 12px">
                            This system call is used to change the file offset of an open file. It allows for random access to a file's contents by specifying the new offset position relative to a reference point (SEEK_SET for the start of the file, SEEK_CUR for the current position, or SEEK_END for the end of the file). lseek() returns the resulting offset location or a negative value if an error occurs.
                        </td>
                    </tr>

                    <tr>
                        <td style="font-size: 25px">
                            stat(), <br>fstat(),<br> and lstat()
                        </td>
                        <td style="font-size: 12px">
                            These calls retrieve information about a file, such as its size, permissions, and timestamps. stat() and lstat() take a file path as an argument, while fstat() takes a file descriptor. lstat() differs from stat() in that it retrieves information about a symbolic link itself rather than the file it points to.
                        </td>
                    </tr>

                    <tr>
                        <td style="font-size: 25px">
                            rename()
                        </td>
                        <td style="font-size: 12px">
                            This system call renames a file or moves it to a different directory. It takes the old file path and the new file path as arguments.
                        </td>
                    </tr>


                    <tr>
                        <td style="font-size: 25px">
                            unlink()
                        </td>
                        <td style="font-size: 12px">
                            This call removes a file from the file system. It takes the file path as an argument. The file's storage space is released when all processes that have the file open close it.
                        </td>
                    </tr>

                    <tr>
                        <td style="font-size: 25px">
                            fsync() and<br> fdatasync()
                        </td>
                        <td style="font-size: 12px">
                            These calls ensure that all buffered data associated with an open file is written to the storage device. fsync() synchronizes both file data and metadata, while fdatasync() synchronizes only file data.
                        </td>
                    </tr>
                </table>
                <aside class="speaker-notes">
                    System calls are a fundamental interface between a user-space application and the Linux kernel. They allow user programs to request services from the kernel, such as file I/O, process management, memory management, and more. When it comes to Linux files, several important system calls facilitate file manipulation and I/O operations:
                </aside>
            </section>
            <section>
                <p>
                    Let's focus on what it looks like when someone is reading the data in our files with a tool like <code>cat</code>
                </p>
                <table>
                    <tr>
                        <td style="font-size: 25px">
                            open()
                        </td>
                        <td style="font-size: 12px">
                            The cat command starts by opening the file for reading. The open() system call takes the file path as an argument and returns a file descriptor, which is a non-negative integer representing the opened file.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            fstat() (optional)
                        </td>
                        <td style="font-size: 12px">
                            This system call retrieves information about the opened file, such as its size, type, and permissions. Although not strictly required for reading the file, it might be used by the cat command for internal purposes.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            read()
                        </td>
                        <td style="font-size: 12px">
                            Once the file is open, the cat command reads the file's contents using the read() system call. This call takes the file descriptor, a buffer to store the read data, and the number of bytes to read as arguments. The read() system call is typically executed in a loop until the entire file has been read.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            write()
                        </td>
                        <td style="font-size: 12px">
                             After reading a chunk of data from the file, the cat command writes the data to the standard output (usually the terminal) using the write() system call. This call takes the file descriptor for the standard output (which is usually 1), the buffer containing the data, and the number of bytes to write as arguments. The write() system call is also executed in a loop, usually in conjunction with the read() loop, to display the entire file's contents.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            close()
                        </td>
                        <td style="font-size: 12px">
                             Once the file's contents have been read and displayed, the cat command closes the file using the close() system call, which takes the file descriptor as an argument. This call releases the resources associated with the file descriptor.
                        </td>
                    </tr>
                </table>
            </section>
            <section>
                <p>Setting up a probe on `read()`'s, and tracking reads by PID might be a good answer</p>
            </section>
            <section>
                <p>
                    We can go through a similar exercise to figure things like:
                </p>

                <ul>
                   <li>
                       File access patterns
                   </li>
                    <li>
                       File modifications
                    </li>
                    <li>
                        File creation and deletion
                    </li>
                    <li>
                       Proccess level access
                    </li>
                    <li>
                       Sensitive data access
                    </li>
                    <li>
                         File locks
                    </li>
                </ul>
            </section>

        </section>
        <section>
            <h2>
                II/iii. SIGNALS OF COMPROMISE: NETWORK ACCESS
            </h2>
        </section>
        <section>
            <small>
                II/ii. SIGNALS OF COMPROMISE: NETWORK
            </small>

            <section>
                <p>
                    Breaking networking into small signals
                </p>
                <small>
                    (Long story very very very short)
                </small>
            </section>
            <section>

                <table>

                    <tr>
                        <td style="font-size: 25px">
                            üëá Application
                        </td>
                        <td style="font-size: 12px;">
                            UI for creating message, formatting, or encryption then the transport layer.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            üëáTransport
                        </td>
                        <td style="font-size: 12px;">
                            (If TCP) establishes a connection via "three-way handshake".
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            (Segmentation)
                        </td>
                        <td style="font-size: 12px;">
                            Once the connection is established, TCP divides the message into smaller chunks called segments.
                            Each segment includes a header containing essential information such as the source and destination port numbers,
                            sequence numbers, and checksums to ensure reliable and ordered transmission.

                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            üëá IP Layer
                        </td>
                        <td style="font-size: 12px;">
                            The segments are then passed to the Internet Protocol (IP) layer. IP adds its own header to each segment,
                            creating IP packets. The header includes the source and destination IP addresses, the time-to-live (TTL) value,
                            and other information required for routing.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            ü§ùData link
                        </td>
                        <td style="font-size: 12px;">
                            The IP packets are handed over to the data link layer, where they are encapsulated into frames.
                            These frames contain additional headers and trailers, such as the source and destination MAC addresses,
                            which are needed for communication within the local network.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            üöÄPhysical layer
                        </td>
                        <td style="font-size: 12px;">
                            Wires and NICs
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            üåéRouting
                        </td>
                        <td style="font-size: 12px;">
                            Your router, which acts as the default gateway, forwards the packets to the next hop in the
                            network based on the destination IP address. This process is repeated across multiple routers and
                            networks until the packets reach the destination computer's network.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            üéìReception
                        </td>
                        <td style="font-size: 12px;">
                            Once the packets arrive at the destination network, they travel through the data link and
                            physical layers, reaching the destination computer's network interface.
                            (More happens on the host)
                        </td>
                    </tr>
                </table>
            </section>
            <section>
                <p>
                    This process uses many syscalls
                </p>
                <table>
                    <tr>
                        <td style="font-size: 25px">
                            socket()
                        </td>
                        <td style="font-size: 12px;">
                            Creates a new socket, returning a file descriptor that refers to it. Takes the address family (e.g., AF_INET for IPv4 or AF_INET6 for IPv6), socket type (e.g., SOCK_STREAM for TCP), and protocol as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            bind()
                        </td>
                        <td style="font-size: 12px;">
                            Assigns a local address (IP and port) to the socket. Often used by servers to listen for incoming connections on a specific port. Takes the socket file descriptor and the local address as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            connect()
                        </td>
                        <td style="font-size: 12px;">
                            Initiates a connection to a remote server for a client application. Takes the socket file descriptor and the destination address (IP and port) as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            listen()
                        </td>
                        <td style="font-size: 12px;">
                            Configures a socket to listen for incoming connection requests from clients. Typically used by servers after bind(). Takes the socket file descriptor and a backlog value (the maximum number of pending connections) as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            accept()
                        </td>
                        <td style="font-size: 12px;">
                            Accepts an incoming connection request from a client, creating a new socket specifically for that connection. Takes the listening socket file descriptor and returns a new file descriptor for the accepted connection.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            recv()
                        </td>
                        <td style="font-size: 12px;">
                            Receives data from the connected remote socket. Takes the socket file descriptor, a pointer to a buffer for the received data, the buffer size, and optional flags as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            read()
                        </td>
                        <td style="font-size: 12px;">
                             A general file I/O system call that can be used to receive data from a connected remote socket. Takes the socket file descriptor, a pointer to a buffer for the received data, and the buffer size as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            select() or poll()
                        </td>
                        <td style="font-size: 12px;">
                            Monitors multiple file descriptors, including sockets, for events such as data availability for reading, readiness for writing, or exceptional conditions. Useful for managing multiple connections in a single-threaded application.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            getsockopt() and setsockopt()
                        </td>
                        <td style="font-size: 12px;">
                            Retrieves or sets socket options, respectively. These system calls allow for adjusting socket settings, such as timeouts, buffer sizes, or enabling/disabling specific features.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            shutdown()
                        </td>
                        <td style="font-size: 12px;">
                            Shuts down part or all of a full-duplex connection on a socket. Takes the socket file descriptor and a flag indicating which part of the connection to shut down (e.g., SHUT_RD for reading, SHUT_WR for writing, or SHUT_RDWR for both) as arguments.
                        </td>
                    </tr>
                    <tr>
                        <td style="font-size: 25px">
                            close()
                        </td>
                        <td style="font-size: 12px;">
                            Closes the socket connection and releases the associated file descriptor. Should be called after the connection is no longer needed to free resources and ensure proper cleanup.
                        </td>
                    </tr>
                </table>

            </section>
            <section>
                <p>
                    Let's focus on the 3-way TCP handshake
                </p>
                <img style="max-height: 35vh" src="assets/3-way-handshake.png">
            </section>
            <section>
                <p>
                    <small>

                        The three-way handshake in TCP is the process of establishing a connection between two endpoints by exchanging SYN (synchronize) and ACK (acknowledge) packets. The system calls involved in this process are typically:
                    </small>
                </p>

                <table>

                    <tr>
                        <td><b>socket():</b></td>
                        <td style="font-size: 12px;">
                            Creates a new socket for communication. This call returns a socket file descriptor that is used for subsequent operations.
                        </td>
                    </tr>
                    <tr>
                        <td>
                         <b>bind():</b>
                        </td>
                        <td style="font-size: 12px;">
                            (Optional) Binds the socket to a specific local address and port. This is not always necessary, as the operating system will assign an ephemeral port automatically if connect() or listen() is called without a prior bind().
                        </td>
                    </tr>
                    <tr>
                        <td>
                         <b>connect()</b>
                        </td>
                        <td style="font-size: 12px;">
                            (for the client side): Initiates a connection to the remote endpoint by sending a SYN packet. The operating system chooses an ephemeral local port if bind() was not called earlier. The client then waits for the server to respond with a SYN-ACK packet.
                        </td>
                    </tr>
                    <tr>
                        <td>
                             <b>listen()</b>
                        </td>
                        <td style="font-size: 12px;">
                            (for the server side): Indicates that the socket is willing to accept incoming connection requests. The server socket is set to listen for incoming SYN packets from clients.
                        </td>
                    </tr>
                    <tr>
                        <td>
                             <b>accept()</b>
                        </td>
                        <td style="font-size: 12px;">
                            (for the server side): Blocks and waits for a connection request from a client. When the server receives a SYN packet, it responds with a SYN-ACK packet. The accept() call returns a new socket file descriptor for the established connection with the client.
                        </td>
                    </tr>
                </table>

                <p>
                    <small>
                        After the client receives the SYN-ACK packet from the server, sends ACK packet to complete handshake. The connection is established, both endpoints can use <code>send()</code> and <code>recv()</code> system calls to transmit data.
                    </small>
                </p>

            </section>
            <section>
                We want to listen to SYN and SYN-ACK to know what server's we're connecting to and how often
                <p>
                    <b>connect()</b> (for the client side): Initiates the connection to the remote endpoint by sending a SYN packet and waits for a SYN-ACK packet in response.
                </p>
            </section>
            <section>
                Let's see this in action
            </section>
        </section>

        <section>
            <h2>
                II/iii. SIGNALS OF COMPROMISE: Ex // Pidtastrophy
            </h2>
        </section>
        <section>
            <small>
                II/iii. SIGNALS OF COMPROMISE: Ex // Pidtastrophy
            </small>
            <section>
                <p>Goal</p>
                <ul>
                    <li>
                        Collect stats on new PIDs created
                    </li>
                    <li>
                        Vizualize and query data
                    </li>
                </ul>
            </section>
            <section>
                <p>Collect: eBPF code that will communicate with our program (compile to eBPF bytecode)</p>
                <pre>
                <code>
int trace_clone(struct pt_regs *ctx) {
	struct data_t data = {};

	struct task_struct *task;
	task = (struct task_struct *)bpf_get_current_task();

	data.pid = task->pid;

	events.perf_submit(ctx, &data, sizeof(data));

	return 0;
}
                </code>
                    </pre>
            </section>
            <section>
                <small>Setup Probes (I'm using BPF Compiler Collection, BCC via <a href="github.com/iovisor/gobpf">iovisor/gobpf</a>)</small>
                <pre>
                <code>
m := bcc.NewModule(source, []string{})
kprobe, err := m.LoadKprobe("__x64_sys_clone")
m.AttachKprobe("__x64_sys_clone", kprobe, -1)
                </code>
                </pre>
            </section>
            <section>
                <small>Setup Counter</small>
                    <pre>
                <code>
pidCounter = prometheus.NewCounter(
    prometheus.CounterOpts{
        Name: "new_pid_count",
        Help: "Counts the new pids created by system",
    },
)
        </code>
                    </pre>
            </section>
            <section>
                <small>Track data</small>
                    <pre>
                <code>
data.Pid = bcc.GetHostByteOrder().Uint32(payload)
fmt.Printf("New process created: PID %d\n", data.Pid)
pidCounter.Inc()
                </code>
                    </pre>
            </section>
            <section>
                <p>

                    <small>
                        Run server!
                    </small>
                </p>

                <img style="max-height: 35vh" src="assets/server-running.png" />
            </section>

            <section>
                <p>
                    <small>
                        See results in prometheus
                    </small>
                </p>
                    <img style="max-height: 35vh;" src="assets/prom-console-go-pidtastrophy.png">
            </section>
            <section>
                <p>
                    <small>
                        Query them in prom
                    </small>

                </p>
                    <img style="max-height: 35vh;" src="assets/prom-console-query-go-pidtastrophy.png">
            </section>
            <section>
                <p>
                    <small>
                        Test that we're tracking stuff
                    </small>
                </p>
                    <pre>
                <code>
for i in {1..1000}; do sleep 5 & done
                </code>
                    </pre>

            </section>
            <section>
                <p>
                    <small>
                        Query again prom (to see spike)
                    </small>

                </p>
                    <img style="max-height: 35vh" src="assets/prom-spike.png">
            </section>
            <section>
                <p>
                    <small>
                        Graph them in grafana
                    </small>
                </p>
                    <img style="max-height: 35vh" src="assets/grafana-go-pidtastrophy.png" >
            </section>
            <section>
                <p>
                    <small>
                        (opt) Setup alerts
                    </small>
                </p>
            </section>

            <section>
                <p>
                    Questions I had: how can I see what system calls I can observe?
                </p>
                <pre>
                    <code>
                        sudo cat /proc/kallsyms
                    </code>
                </pre>
                <img style="max-height: 25vh;" src="assets/ksys.png" />
            </section>
            <section>
                <p>
                    Questions I had: How do I know what systemcalls a program / action uses? (strace)
                </p>
                <pre>
                    <code>
                        strace cat example.txt
                    </code>
                </pre>
                <img style="max-height: 25vh;" src="assets/strace-example.png" />
            </section>

            <section>
               <p>
                   I've setup all of the code to run ü§ûwith Vagrant, Ansible, Prom, Grafana with command if you want to play around
                   <a href="github.com/ryanlabouve/hbdz">github.com/ryanlabouve/hbdz</a>
               </p>
            </section>
        </section>

        <!-- ############################################# -->
        <!-- ############################################# -->
        <!-- 03. CONCLUSIONS IN THE WILD -->
        <!-- ############################################# -->
        <section>
            <h2>
                III. CONCLUSIONS IN THE WILD
            </h2>
        </section>
        <section>
            <small>
                III. CONCLUSIONS IN THE WILD
            </small>
            <section>
                <p>The bigger and more abstract our tools get, the more we lose touch with our systems</p>
            </section>
            <section>
                <p>We are not beholden to BigTools to get insights (but they can help)</p>
            </section>
            <section>
                <p>
                    My favorite OSS tools for security observability: eBPF, Prometheus, Grafana
                </p>
            </section>
            <section>
                <p>Earlier I said relying on big signals is a cat and mouse game</p>
                <p>Trying to break new vulns using small signals is a ghost hunt</p>
            </section>
            <section>

            </section>
            <section>
                <p>Happy hunting</p>
            </section>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,
        slideNumber: true,
        showSlideNumber: 'all',
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>
</body>
</html>
